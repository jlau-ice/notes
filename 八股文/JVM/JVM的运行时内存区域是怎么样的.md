
一共被分成五块地方
方法区 堆 虚拟机栈  本地方法栈 程序计数器
前面两个是所有线程共享的，后面三线程私有。

1. 方法区

所有线程共享，存着类的结构信息、常量、静态变量。所有线程都能访问。
jdk8 之前用永久（PermGen）实现容易内存溢出，现在换成元空间（Metaspace）用本地内存。更靠谱。

2. 堆

最大的共享区，专门放对象和数组。垃圾回收的主战场。新对象出生，老对象养老。

3. 虚拟机栈

每个线程独享的工作台，存局部变量、操作数栈、动态连接和方法入口信息。基本类型变量和对象引用都存这里。
生命周期和线程相同。

4. 本地方法栈

类似虚拟机栈，用来分配JNI调用本地代码（C++）服务。
也是线程私有的，用来分配内存给那些非Java方法。

5. 程序计数器

每个线程独有，记录当前线程字节码指令的地址或行号。线程切换时会帮你记录位置，不会迷路。唯一一个不会发生内存溢出的地方

## 回答重点

内存区域其实指的就是 JVM 的运行时数据区。它分成五个主要区域：**方法区、堆、虚拟机栈、本地方法栈和程序计数器**。

这些区域有的线程共享，有的线程私有，帮助 JVM 高效地存储数据、执行代码。如果你想象 JVM 像个大仓库，这些就是不同的“储物间”，各司其职，避免数据乱套。

简单说说每个部分干嘛：

1）**方法区（Method Area）**：

这是大家共享的“知识库”（线程共享区域），存着类的结构信息、常量、静态变量。所有线程都能访问。

JDK 8 之前用永久代（PermGen）实现，容易内存溢出，现在换成元空间（Metaspace），用本地内存，更靠谱。

2）**堆（Heap）**：

最大的共享区，专门放对象和数组。垃圾回收（GC）主要在这儿干活，新对象出生，老对象养老。

3）**虚拟机栈（JVM Stack）**：

每个线程独享的工作台，存**局部变量、操作数栈、动态链接和方法出口信息**。基本类型变量和对象引用都存这。

注意，栈是线程私有的，生命周期与线程相同。

4）**本地方法栈（Native Method Stack）**：

类似虚拟机栈，但专为 JNI 调用本地代码（比如 C++）服务。

也是线程私有的，用来分配内存给那些非 Java 方法。

5）**程序计数器（Program Counter Register）**：

每个线程都有一个独立的程序计数器，属于线程私有。作用是保存当前线程执行的字节码指令的地址或行号。

线程切换时，它帮你记住位置，不会迷路。唯一不会 OOM 的地方，因为太简单了。

还有一个**直接内存（Direct Memory）** 这里也提一下，它属于 JVM 之外的内存区域，但挺重要。它通过 NIO 的 ByteBuffer 直接分配本机内存，不走堆，受系统内存限制，但速度快，适合大文件传输。


## 扩展知识

### **方法区和永久代的区别**：

- JDK 7 及之前，HotSpot 使用永久代（PermGen）实现方法区，主要存储类信息、静态变量等。
- JDK 8 之后，永久代被移除，改为使用元空间（Metaspace），元空间使用本地内存（Native Memory）来提高性能和避免 OOM 错误。元空间可以动态调整大小，而永久代大小是固定的。

### **堆内存的进一步划分**

- **Eden 区**：新对象最初会被分配到 Eden 区，且 Eden 区较大，频繁进行垃圾回收。
- **Survivor 区**：两个 Survivor 区 S0 和 S1 交替使用，新对象在 Eden 区经过一次垃圾回收后存放到其中一个 Survivor 区，进一步存活的对象会移动到另一个 Survivor 区，最终晋升到老年代。
- **老年代**：长生命周期对象经过多次垃圾回收后会被移到老年代，Major GC 在老年代进行，频率较低但耗时较长。

### **虚拟机栈和栈帧**

每当一个方法被调用时，虚拟机会在栈中创建一个新的**栈帧（Stack Frame）**，该栈帧用于存储方法的局部变量表、操作数栈、常量池引用等。方法执行完毕后，栈帧会被弹出，释放内存。