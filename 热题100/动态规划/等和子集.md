
三个剪枝
1. 如果有数大于 sum/2 直接返回
2. 如果 sum/2 是奇数直接剪枝
3. 如果提前找到 直接返回

讲一下状态转移方程 这是经过空间优化后的。
`dp[j] = dp[j] || dp[j - nums[i]];`
如果 `dp[j]` 上一轮能凑出来 就是true，多一个数的情况下，这一轮一定能凑出来。大不了不选这个数对吧。
如果凑不出来呢？

就去看看 `dp[j - nums[i]]` 。

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int i : nums) {
            sum += i;
        }
        if (sum % 2 != 0) {
            return false;
        }
        int c = sum / 2;
        boolean[] dp = new boolean[c + 1];
        dp[0] = true;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > c) {
                return false;
            }
            for (int j = c; j >= nums[i]; j--) {
                dp[j] = dp[j] || dp[j - nums[i]];
            }
            if (dp[c])
                return true;
        }
        return dp[c];
    }
}
```
