## 两两交换链表节点
[题目地址](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
这个有点难度。
~~需要三个指针
p1 p2 p3 依次指向链表的 哨兵 头 头.next 
这里有个前提，如果链表长度小于2,直接返回原链表就行了
接下来操作。
p2 ——> p3.next
p3 ——> p2 
p1 ——> p3
完成第一个反转。
主要反转的是 p2 p3 指向的节点。
接下来
p1 指向 p2 节点的位置，也就是下两个交换节点的前一个节点
p2 p3 依次指向 下一个 和下两个节点 
有一个为空就直接返回了。~~

不需要三个指针，换个思路，需要一个指针`p1`，指向哨兵节点。
如果哨兵节点后面有两个节点进入循环,否则退出。
获取哨兵节点后面的两个节点指针`p2`、`p3`。
进行交换操作
```
p1.next = p3;
p2.next = p3.next;
p3.next = p2;
```
完成交换，
更新`p1`,`p1`指针指向刚刚交换完的后面一个节点即`p1=p2` ,直到不满足循环条件

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode dummy = new ListNode(-1, head);
        ListNode p1 = dummy;
        while (p1.next != null && p1.next.next != null) {
            ListNode p2 = p1.next;
            ListNode p3 = p1.next.next;
            p1.next = p3;
            p2.next = p3.next;
            p3.next = p2;
            p1 = p2;
        }
        return dummy.next;
    }
}
```