[题目地址](https://leetcode.cn/problems/palindrome-linked-list)
这题的是个简单题目，但是如果让你用O(1) 的时间复杂度你会这么做？
我能想到的就是快慢指针从中间断开，得到两个链表一个反转，再进行比较。
我感觉难的地方是如何断开。这么找到中间点。如果是奇数个数链表呢？
慢指针还应该停在断开部分的前一个节点，那样我们使用一个哨兵节点。都从这里开始
终止条件是快指针 为空或者快指针的下个节点为空，这样就能保证，断开后的链表就算是奇数后面的比前面的少一个。
以后面为准就行了。
代码实现
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode dummy = new ListNode(-1, head);
        ListNode fast = dummy;
        ListNode slow = dummy;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode n2 = res(slow.next);
        slow.next = null;
        while (n2 != null) {
            if(n2.val != head.val) {
                return false;
            }
            n2 = n2.next;
            head = head.next;
        }
        return true;
    }

    public ListNode res(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode pre = null;
        ListNode cur = head;
        while(cur!=null) {
            ListNode next = cur.next;
            cur.next = pre;

            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```
突然发现不需要哨兵节点。
如果fast == null 说明是偶数。
slow 指针回落在新链表的头节点。
如果fast != null 说明是奇数。
slow 会落在中点，slow 下一位是新链表的头节点。
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) return true;
        // 快慢指针找中点
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        // 如果 fast 不为空，则为奇数长度，跳过中点
        if (fast != null) {
            slow = slow.next;
        }
        // 反转后半段
        ListNode n2 = reverse(slow);
        // 比较前后两部分
        ListNode n1 = head;
        while (n2 != null) {
            if (n1.val != n2.val) return false;
            n1 = n1.next;
            n2 = n2.next;
        }
        return true;
    }
    private ListNode reverse(ListNode head) {
        ListNode pre = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
}
```