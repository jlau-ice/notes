
## 反转链表
[题目地址](https://leetcode.cn/problems/reverse-linked-list/description/)
经典的反转链表题目，之前做过很多次，但确实容易忘。不过现在应该不会再忘了，和“两数之和”一样，应该刻在脑子里了。

说一下思路吧：

需要两个指针：`pre` 和 `current`，还有一个临时指针用来记录下一个节点，否则断开后就找不到下一个节点了。

- 首先 `pre` 指向 `null`，`current` 指向头节点。
    
- 记录 `current` 的下一个节点 `next`。
    
- 因为下一步要断开 `current` 和 `next` 的连接，所以让 `current.next = pre`。
    
- 完成第一个节点的反转后，开始移动指针：
    
    - `pre` 指向刚刚的 `current`
        
    - `current` 指向刚刚保存的 `next`
        
- 然后继续重复上述过程，直到 `current == null`。
    
- 最后返回 `pre` 指针作为新的链表头。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

很简单撕完了。



## 合并两个有序链表

[题目地址](https://leetcode.cn/problems/merge-two-sorted-lists/)
这个也是简单题目，但是后面有些题目需要借助这些思路来实现
思路就是构建一个哨兵节点 指向两个链表头节点最小的一个，然后去连接这个头节点，再断开，再去连接新的比较小的头节点，知道一个链表完全为空。最后把剩余的部分加到后面就行了。



## 两两交换链表节点
[题目地址](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
这个有点难度。
~~需要三个指针
p1 p2 p3 依次指向链表的 哨兵 头 头.next 
这里有个前提，如果链表长度小于2,直接返回原链表就行了
接下来操作。
p2 ——> p3.next
p3 ——> p2 
p1 ——> p3
完成第一个反转。
主要反转的是 p2 p3 指向的节点。
接下来
p1 指向 p2 节点的位置，也就是下两个交换节点的前一个节点
p2 p3 依次指向 下一个 和下两个节点 
有一个为空就直接返回了。~~

不需要三个指针，换个思路，需要一个指针`p1`，指向哨兵节点。
如果哨兵节点后面有两个节点进入循环,否则退出。
获取哨兵节点后面的两个节点指针`p2`、`p3`。
进行交换操作
```
p1.next = p3;
p2.next = p3.next;
p3.next = p2;
```
完成交换，
更新`p1`,`p1`指针指向刚刚交换完的后面一个节点即`p1=p2` ,直到不满足循环条件

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode dummy = new ListNode(-1, head);
        ListNode p1 = dummy;
        while (p1.next != null && p1.next.next != null) {
            ListNode p2 = p1.next;
            ListNode p3 = p1.next.next;
            p1.next = p3;
            p2.next = p3.next;
            p3.next = p2;
            p1 = p2;
        }
        return dummy.next;
    }
}
```


## 





