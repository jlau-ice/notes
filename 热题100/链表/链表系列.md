
## 反转链表
[题目地址](https://leetcode.cn/problems/reverse-linked-list/description/)
经典的反转链表题目，之前做过很多次，但确实容易忘。不过现在应该不会再忘了，和“两数之和”一样，应该刻在脑子里了。

说一下思路吧：

需要两个指针：`pre` 和 `current`，还有一个临时指针用来记录下一个节点，否则断开后就找不到下一个节点了。

- 首先 `pre` 指向 `null`，`current` 指向头节点。
    
- 记录 `current` 的下一个节点 `next`。
    
- 因为下一步要断开 `current` 和 `next` 的连接，所以让 `current.next = pre`。
    
- 完成第一个节点的反转后，开始移动指针：
    
    - `pre` 指向刚刚的 `current`
        
    - `current` 指向刚刚保存的 `next`
        
- 然后继续重复上述过程，直到 `current == null`。
    
- 最后返回 `pre` 指针作为新的链表头。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

很简单撕完了。



## 合并两个有序链表

[题目地址](https://leetcode.cn/problems/merge-two-sorted-lists/)
这个也是简单题目，但是后面有些题目需要借助这些思路来实现
思路就是构建一个哨兵节点 指向两个链表头节点最小的一个，然后去连接这个头节点，再断开，再去连接新的比较小的头节点，知道一个链表完全为空。最后把剩余的部分加到后面就行了。



## 两两交换链表节点
[题目地址](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
这个有点难度。
需要三个指针

p1 p2 p3 依次指向链表的 哨兵 头 头.next 

这里有个前提，如果链表长度小于2,直接返回原链表就行了

接下来操作。

p2 ——> p3.next

p3 ——> p2 

p1 ——> p3

完成第一个反转。

主要反转的是 p2 p3 指向的节点。

接下来
p1 指向 p2 节点的位置，也就是下两个交换节点的前一个节点

p2 p3 依次指向 下一个 和下两个节点 
有一个为空就直接返回了。



## 





