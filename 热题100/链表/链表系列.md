
## åè½¬é“¾è¡¨
[é¢˜ç›®åœ°å€](https://leetcode.cn/problems/reverse-linked-list/description/)
ç»å…¸çš„åè½¬é“¾è¡¨é¢˜ç›®ï¼Œä¹‹å‰åšè¿‡å¾ˆå¤šæ¬¡ï¼Œä½†ç¡®å®å®¹æ˜“å¿˜ã€‚ä¸è¿‡ç°åœ¨åº”è¯¥ä¸ä¼šå†å¿˜äº†ï¼Œå’Œâ€œä¸¤æ•°ä¹‹å’Œâ€ä¸€æ ·ï¼Œåº”è¯¥åˆ»åœ¨è„‘å­é‡Œäº†ã€‚

è¯´ä¸€ä¸‹æ€è·¯å§ï¼š

éœ€è¦ä¸¤ä¸ªæŒ‡é’ˆï¼š`pre` å’Œ `current`ï¼Œè¿˜æœ‰ä¸€ä¸ªä¸´æ—¶æŒ‡é’ˆç”¨æ¥è®°å½•ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦åˆ™æ–­å¼€åå°±æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹äº†ã€‚

- é¦–å…ˆ `pre` æŒ‡å‘ `null`ï¼Œ`current` æŒ‡å‘å¤´èŠ‚ç‚¹ã€‚
    
- è®°å½• `current` çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ `next`ã€‚
    
- å› ä¸ºä¸‹ä¸€æ­¥è¦æ–­å¼€ `current` å’Œ `next` çš„è¿æ¥ï¼Œæ‰€ä»¥è®© `current.next = pre`ã€‚
    
- å®Œæˆç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„åè½¬åï¼Œå¼€å§‹ç§»åŠ¨æŒ‡é’ˆï¼š
    
    - `pre` æŒ‡å‘åˆšåˆšçš„ `current`
        
    - `current` æŒ‡å‘åˆšåˆšä¿å­˜çš„ `next`
        
- ç„¶åç»§ç»­é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ° `current == null`ã€‚
    
- æœ€åè¿”å› `pre` æŒ‡é’ˆä½œä¸ºæ–°çš„é“¾è¡¨å¤´ã€‚

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

å¾ˆç®€å•æ’•å®Œäº†ã€‚



## åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

[é¢˜ç›®åœ°å€](https://leetcode.cn/problems/merge-two-sorted-lists/)
è¿™ä¸ªä¹Ÿæ˜¯ç®€å•é¢˜ç›®ï¼Œä½†æ˜¯åé¢æœ‰äº›é¢˜ç›®éœ€è¦å€ŸåŠ©è¿™äº›æ€è·¯æ¥å®ç°
æ€è·¯å°±æ˜¯æ„å»ºä¸€ä¸ªå“¨å…µèŠ‚ç‚¹ æŒ‡å‘ä¸¤ä¸ªé“¾è¡¨å¤´èŠ‚ç‚¹æœ€å°çš„ä¸€ä¸ªï¼Œç„¶åå»è¿æ¥è¿™ä¸ªå¤´èŠ‚ç‚¹ï¼Œå†æ–­å¼€ï¼Œå†å»è¿æ¥æ–°çš„æ¯”è¾ƒå°çš„å¤´èŠ‚ç‚¹ï¼ŒçŸ¥é“ä¸€ä¸ªé“¾è¡¨å®Œå…¨ä¸ºç©ºã€‚æœ€åæŠŠå‰©ä½™çš„éƒ¨åˆ†åŠ åˆ°åé¢å°±è¡Œäº†ã€‚



## ä¸¤ä¸¤äº¤æ¢é“¾è¡¨èŠ‚ç‚¹
[é¢˜ç›®åœ°å€](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
è¿™ä¸ªæœ‰ç‚¹éš¾åº¦ã€‚
~~éœ€è¦ä¸‰ä¸ªæŒ‡é’ˆ
p1 p2 p3 ä¾æ¬¡æŒ‡å‘é“¾è¡¨çš„ å“¨å…µ å¤´ å¤´.next 
è¿™é‡Œæœ‰ä¸ªå‰æï¼Œå¦‚æœé“¾è¡¨é•¿åº¦å°äº2,ç›´æ¥è¿”å›åŸé“¾è¡¨å°±è¡Œäº†
æ¥ä¸‹æ¥æ“ä½œã€‚
p2 â€”â€”> p3.next
p3 â€”â€”> p2 
p1 â€”â€”> p3
å®Œæˆç¬¬ä¸€ä¸ªåè½¬ã€‚
ä¸»è¦åè½¬çš„æ˜¯ p2 p3 æŒ‡å‘çš„èŠ‚ç‚¹ã€‚
æ¥ä¸‹æ¥
p1 æŒ‡å‘ p2 èŠ‚ç‚¹çš„ä½ç½®ï¼Œä¹Ÿå°±æ˜¯ä¸‹ä¸¤ä¸ªäº¤æ¢èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
p2 p3 ä¾æ¬¡æŒ‡å‘ ä¸‹ä¸€ä¸ª å’Œä¸‹ä¸¤ä¸ªèŠ‚ç‚¹ 
æœ‰ä¸€ä¸ªä¸ºç©ºå°±ç›´æ¥è¿”å›äº†ã€‚~~

ä¸éœ€è¦ä¸‰ä¸ªæŒ‡é’ˆï¼Œæ¢ä¸ªæ€è·¯ï¼Œéœ€è¦ä¸€ä¸ªæŒ‡é’ˆ`p1`ï¼ŒæŒ‡å‘å“¨å…µèŠ‚ç‚¹ã€‚
å¦‚æœå“¨å…µèŠ‚ç‚¹åé¢æœ‰ä¸¤ä¸ªèŠ‚ç‚¹è¿›å…¥å¾ªç¯,å¦åˆ™é€€å‡ºã€‚
è·å–å“¨å…µèŠ‚ç‚¹åé¢çš„ä¸¤ä¸ªèŠ‚ç‚¹æŒ‡é’ˆ`p2`ã€`p3`ã€‚
è¿›è¡Œäº¤æ¢æ“ä½œ
```
p1.next = p3;
p2.next = p3.next;
p3.next = p2;
```
å®Œæˆäº¤æ¢ï¼Œ
æ›´æ–°`p1`,`p1`æŒ‡é’ˆæŒ‡å‘åˆšåˆšäº¤æ¢å®Œçš„åé¢ä¸€ä¸ªèŠ‚ç‚¹å³`p1=p2` ,ç›´åˆ°ä¸æ»¡è¶³å¾ªç¯æ¡ä»¶

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode dummy = new ListNode(-1, head);
        ListNode p1 = dummy;
        while (p1.next != null && p1.next.next != null) {
            ListNode p2 = p1.next;
            ListNode p3 = p1.next.next;
            p1.next = p3;
            p2.next = p3.next;
            p3.next = p2;
            p1 = p2;
        }
        return dummy.next;
    }
}
```


## ç¯å½¢é“¾è¡¨I
[é¢˜ç›®åœ°å€](https://leetcode.cn/problems/linked-list-cycle-ii)
è¿™é¢˜ä½¿ç”¨å“ˆå¸Œè¡¨å¾ˆå®¹æ˜“åšå‡ºæ¥ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦å°±æ˜¯`O(N)`ï¼Œæœ‰æ²¡æœ‰åŠæ³•ç”¨æ—¶é—´æŒ‰å¤æ‚åº¦ä¸º`O(1)`çš„åšæ³•å‘¢ï¼Ÿæœ‰çš„æœ‰çš„å…„å¼Ÿã€‚`I`ä¸­ç”¨åŒæŒ‡é’ˆå¯ä»¥åšåˆ°ç©ºé—´å¤æ‚åº¦ä¸º`O(1)`è¿™é‡Œå¯ä»¥å‚è€ƒåŒæŒ‡é’ˆçš„åšæ³•ã€‚
å¦‚ä½•ç†è§£å‘¢ï¼Ÿ
å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ`fast`,`slow`ã€‚`fast`æ¯æ¬¡ç§»åŠ¨ä¸¤æ­¥ï¼Œ`slow`æ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ã€‚è¿™æ ·å¦‚æœé“¾è¡¨æœ‰ç¯æœ€åä»–ä»¬ä¸€å®šä¼šåœ¨ç¯ä¸­ç›¸é‡ã€‚åˆ¤æ–­`fast.next`æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœæ²¡æœ‰ç¯å°±é€€å‡ºå¾ªç¯äº†ã€‚
åœ¨ç¯ä¸­ç›¸é‡ï¼Œæ­¤æ—¶faståœ¨ç¯ä¸­è·‘äº†Nåœˆäº†ï¼Œæ‰€ä»¥ä¸‹é¢ç­‰å¼æˆç«‹

ä¸€å¼€å§‹ä»¤å¿«æŒ‡é’ˆ `fast` å’Œæ…¢æŒ‡é’ˆ `slow` éƒ½ä½äºå¤´éƒ¨ï¼Œç„¶åï¼š

- `fast` æ¯æ¬¡èµ° **2 æ­¥**
    
- `slow` æ¯æ¬¡èµ° **1 æ­¥**

å› æ­¤ï¼Œ**fast èµ°è¿‡çš„æ­¥æ•°å§‹ç»ˆæ˜¯ slow çš„ 2 å€**ã€‚

---

### è®¾å®šå˜é‡

- ä»å¤´åˆ°ç¯å…¥å£çš„è·ç¦»ï¼š**a**
    
- ç¯çš„é•¿åº¦ï¼š**b**
    
- ç›¸é‡æ—¶ï¼Œslow åœ¨ç¯å†…èµ°äº†ï¼š**x**
    
- fast æ¯” slow å¤šèµ°äº†ï¼š**n åœˆï¼ˆn ä¸ºæ­£æ•´æ•°ï¼‰**

---
### è·ç¦»å…³ç³»

- slow èµ°è¿‡çš„è·ç¦»ï¼š  
    `a + x`

- fast èµ°è¿‡çš„è·ç¦»ï¼š  
    `a + x + n * b`
 
ç”±äº fast å§‹ç»ˆæ˜¯ slow çš„ä¸¤å€ï¼Œå› æ­¤æœ‰ï¼š

$$
2(a+x)=a+x+nb2(a + x) = a + x + nb2(a+x)=a+x+nb
$$
åŒ–ç®€å¾—åˆ°ï¼š
$$
a+x=nba + x = nba+x=nb
$$
---

### å…³é”®ç»“è®º

> **æ…¢æŒ‡é’ˆå†å¾€å‰èµ° a æ­¥ï¼Œå°±æ­£å¥½å›åˆ°ç¯å…¥å£**

å› ä¸ºï¼š

- `nb` è¡¨ç¤ºç»•ç¯æ•´æ•´æ•°åœˆå›å…¥å£
    
- å½“å‰ slow åœ¨ç¯å†…ä¸º `x`
    
- æ‰€ä»¥å·®å€¼ `nb - x = a`
    
- åˆšå¥½æ˜¯ä»ç›¸é‡ç‚¹å›åˆ°å…¥å£çš„è·ç¦»  
    ğŸ‘‰ **slow å†èµ° a æ­¥å¿…åˆ°å…¥å£**


```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (slow == fast) {
                while (head != slow) {
                    head = head.next;
                    slow = slow.next;
                }
                return head;
            }
        }
        return null;
    }
}
```

## å›æ–‡é“¾è¡¨
[é¢˜ç›®åœ°å€](https://leetcode.cn/problems/palindrome-linked-list)
è¿™é¢˜çš„æ˜¯ä¸ªç®€å•é¢˜ç›®ï¼Œä½†æ˜¯å¦‚æœè®©ä½ ç”¨O(1) çš„æ—¶é—´å¤æ‚åº¦ä½ ä¼šè¿™ä¹ˆåšï¼Ÿ
æˆ‘èƒ½æƒ³åˆ°çš„å°±æ˜¯å¿«æ…¢æŒ‡é’ˆä»ä¸­é—´æ–­å¼€ï¼Œå¾—åˆ°ä¸¤ä¸ªé“¾è¡¨ä¸€ä¸ªåè½¬ï¼Œå†è¿›è¡Œæ¯”è¾ƒã€‚
æˆ‘æ„Ÿè§‰éš¾çš„åœ°æ–¹æ˜¯å¦‚ä½•æ–­å¼€ã€‚è¿™ä¹ˆæ‰¾åˆ°ä¸­é—´ç‚¹ã€‚å¦‚æœæ˜¯å¥‡æ•°ä¸ªæ•°é“¾è¡¨å‘¢ï¼Ÿ
æ…¢æŒ‡é’ˆè¿˜åº”è¯¥åœåœ¨æ–­å¼€éƒ¨åˆ†çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‚£æ ·æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªå“¨å…µèŠ‚ç‚¹ã€‚éƒ½ä»è¿™é‡Œå¼€å§‹
ç»ˆæ­¢æ¡ä»¶æ˜¯å¿«æŒ‡é’ˆ ä¸ºç©ºæˆ–è€…å¿«æŒ‡é’ˆçš„ä¸‹ä¸ªèŠ‚ç‚¹ä¸ºç©ºï¼Œè¿™æ ·å°±èƒ½ä¿è¯ï¼Œæ–­å¼€åçš„é“¾è¡¨å°±ç®—æ˜¯å¥‡æ•°åé¢çš„æ¯”å‰é¢çš„å°‘ä¸€ä¸ªã€‚
ä»¥åé¢ä¸ºå‡†å°±è¡Œäº†ã€‚
ä»£ç å®ç°
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode dummy = new ListNode(-1, head);
        ListNode fast = dummy;
        ListNode slow = dummy;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode n2 = res(slow.next);
        slow.next = null;
        while (n2 != null) {
            if(n2.val != head.val) {
                return false;
            }
            n2 = n2.next;
            head = head.next;
        }
        return true;
    }

    public ListNode res(ListNode head) {
        if(head == null || head.next == null) {
            return head;
        }
        ListNode pre = null;
        ListNode cur = head;
        while(cur!=null) {
            ListNode next = cur.next;
            cur.next = pre;

            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```
çªç„¶å‘ç°ä¸éœ€è¦å“¨å…µèŠ‚ç‚¹ã€‚
å¦‚æœfast == null è¯´æ˜æ˜¯å¶æ•°ã€‚
slow æŒ‡é’ˆå›è½åœ¨æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚
å¦‚æœfast != null è¯´æ˜æ˜¯å¥‡æ•°ã€‚
slow ä¼šè½åœ¨ä¸­ç‚¹ï¼Œslow ä¸‹ä¸€ä½æ˜¯æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) return true;
        // å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        // å¦‚æœ fast ä¸ä¸ºç©ºï¼Œåˆ™ä¸ºå¥‡æ•°é•¿åº¦ï¼Œè·³è¿‡ä¸­ç‚¹
        if (fast != null) {
            slow = slow.next;
        }
        // åè½¬ååŠæ®µ
        ListNode n2 = reverse(slow);
        // æ¯”è¾ƒå‰åä¸¤éƒ¨åˆ†
        ListNode n1 = head;
        while (n2 != null) {
            if (n1.val != n2.val) return false;
            n1 = n1.next;
            n2 = n2.next;
        }
        return true;
    }
    private ListNode reverse(ListNode head) {
        ListNode pre = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
}
```


